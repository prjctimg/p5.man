p5-webglðŸŽ®.txt    p5.js webgl documentation    p5

==============================================================================
p5.js Webgl Module    *p5-webgl*

p5.js Version: 1.7.7~
Last Updated: 2026-02-06 18:38:12~

==============================================================================
CONTENTS                                                    *p5-webgl-contents*


## Table of Contents

### Functions

- plane
- box
- sphere
- cylinder
- cone
- ellipsoid
- torus
- wheel
- debugMode
- debugMode
- debugMode
- debugMode
- debugMode
- debugMode
- called
- called
- called
- called
- called
- light
- light
- light
- light
- light
- as
- as
- as
- as
- point
- point
- point
- point
- ambientLight
- pointLight
- pointLight
- pointLight
- pointLight
- pointLight
- pointLight
- pointLight
- pointLight
- pointLight
- functions
- loadModel
- preload
- createShader
- resetShader
- beginShape
- points
- size
- normalMaterial
- ambientMaterial
- ambientMaterial
- ambientMaterial
- range
- emissiveMaterial
- emissiveMaterial
- reflective
- reflective
- reflective
- gloss
- perspective
- ortho
- frustum
- counterclockwise
- counterclockwise
- lookAt
- camera
- move
- setPosition
- set
- orbitControl
- sketch
- frustum
- ortho
- perspective
- current
- current
- vertexNormal
- false
- false
- constructor
- pixelDensity
- autoSized
- createCamera
- remove
- end
- begin
- begin
- imageMode
- imageMode
- constructor
- computeNormals
- averageNormals
- averagePoleNormals
- normalize
- programs

### Variables

- angle
- eyeY
- eyeZ
- centerX
- centerY
- centerZ
- upX
- upY
- upZ
- target
- color
- depth

---

## Functions

### plane

*   Draw a plane with given a width and height
  @param [width] width of the plane
  @param [height] height of the plane
  @param [detailX] Optional number of triangle
  subdivisions in x-dimension
  @param [detailY] Optional number of triangle
  subdivisions in y-dimension
  @chainable

*Sub-module: 3d_primitives*

---

### box

*   Draw a box with given width, height and depth
  @param [width] width of the box
  @param [height] height of the box
  @param [depth] depth of the box
  @param [detailX] Optional number of triangle
  subdivisions in x-dimension
  @param [detailY] Optional number of triangle
  subdivisions in y-dimension
  @chainable

*Sub-module: 3d_primitives*

---

### sphere

*   Draw a sphere with given radius. DetailX and
  detailY determines the number of subdivisions in
  the x-dimension and the y-dimension of a sphere.
  More subdivisions make the sphere seem smoother.
  The recommended maximum values are both 24. Using
  a value greater than 24 may cause a warning or
  slow down the browser.
  @param [radius] radius of circle
  @param [detailX] optional number of subdivisions
  in x-dimension
  @param [detailY] optional number of subdivisions
  in y-dimension
  @chainable

*Sub-module: 3d_primitives*

---

### cylinder

*   Draw a cylinder with given radius and height
  DetailX and detailY determines the number of
  subdivisions in the x-dimension and the
  y-dimension of a cylinder. More subdivisions make
  the cylinder seem smoother. The recommended
  maximum value for detailX is 24. Using a value
  greater than 24 may cause a warning or slow down
  the browser.
  @param [radius] radius of the surface
  @param [height] height of the cylinder
  @param [detailX] number of subdivisions in
  x-dimension; default is 24
  @param [detailY] number of subdivisions in
  y-dimension; default is 1
  @param [bottomCap] whether to draw the bottom of
  the cylinder
  @param [topCap] whether to draw the top of the
  cylinder
  @chainable

*Sub-module: 3d_primitives*

---

### cone

*   Draw a cone with given radius and height DetailX
  and detailY determine the number of subdivisions
  in the x-dimension and the y-dimension of a cone.
  More subdivisions make the cone seem smoother. The
  recommended maximum value for detailX is 24. Using
  a value greater than 24 may cause a warning or
  slow down the browser.
  @param [radius] radius of the bottom surface
  @param [height] height of the cone
  @param [detailX] number of segments, the more
  segments the smoother geometry default is 24
  @param [detailY] number of segments, the more
  segments the smoother geometry default is 1
  @param [cap] whether to draw the base of the cone
  @chainable

*Sub-module: 3d_primitives*

---

### ellipsoid

*   Draw an ellipsoid with given radius DetailX and
  detailY determine the number of subdivisions in
  the x-dimension and the y-dimension of a cone.
  More subdivisions make the ellipsoid appear to be
  smoother. Avoid detail number above 150, it may
  crash the browser.
  @param [radiusx] x-radius of ellipsoid
  @param [radiusy] y-radius of ellipsoid
  @param [radiusz] z-radius of ellipsoid
  @param [detailX] number of segments, the more
  segments the smoother geometry default is 24.
  Avoid detail number above 150, it may crash the
  browser.
  @param [detailY] number of segments, the more
  segments the smoother geometry default is 16.
  Avoid detail number above 150, it may crash the
  browser.
  @chainable

*Sub-module: 3d_primitives*

---

### torus

*   Draw a torus with given radius and tube radius
  DetailX and detailY determine the number of
  subdivisions in the x-dimension and the
  y-dimension of a torus. More subdivisions make the
  torus appear to be smoother. The default and
  maximum values for detailX and detailY are 24 and
  16, respectively. Setting them to relatively small
  values like 4 and 6 allows you to create new
  shapes other than a torus.
  @param [radius] radius of the whole ring
  @param [tubeRadius] radius of the tube
  @param [detailX] number of segments in
  x-dimension, the more segments the smoother
  geometry default is 24
  @param [detailY] number of segments in
  y-dimension, the more segments the smoother
  geometry default is 16
  @chainable

*Sub-module: 3d_primitives*

---

### wheel

*   Allows movement around a 3D sketch using a mouse
  or trackpad or touch. Left-clicking and dragging
  or swipe motion will rotate the camera position
  about the center of the sketch, right-clicking and
  dragging or multi-swipe will pan the camera
  position without rotation, and using the mouse
  wheel (scrolling) or pinch in/out will move the
  camera further or closer from the center of the
  sketch. This function can be called with
  parameters dictating sensitivity to mouse/touch
  movement along the X and Y axes. Calling this
  function without parameters is equivalent to
  calling orbitControl(1,1). To reverse direction of
  movement in either axis, enter a negative number
  for sensitivity.
  @param [sensitivityX] sensitivity to mouse
  movement along X axis
  @param [sensitivityY] sensitivity to mouse
  movement along Y axis
  @param [sensitivityZ] sensitivity to scroll
  movement along Z axis
  @param [options] An optional object that can
  contain additional settings, disableTouchActions -
  Boolean, default value is true. Setting this to
  true makes mobile interactions smoother by
  preventing accidental interactions with the page
  while orbiting. But if you're already doing it via
  css or want the default touch actions, consider
  setting it to false. freeRotation - Boolean,
  default value is false. By default, horizontal
  movement of the mouse or touch pointer rotates the
  camera around the y-axis, and vertical movement
  rotates the camera around the x-axis. But if
  setting this option to true, the camera always
  rotates in the direction the pointer is moving.
  For zoom and move, the behavior is the same
  regardless of true/false.
  @chainable

*Sub-module: interaction*

---

### debugMode

*   debugMode() helps visualize 3D space by adding a
  grid to indicate where the â€˜groundâ€™ is in a sketch
  and an axes icon which indicates the +X, +Y, and
  +Z directions. This function can be called without
  parameters to create a default grid and axes icon,
  or it can be called according to the examples
  above to customize the size and position of the
  grid and/or axes icon. The grid is drawn using the
  most recently set stroke color and weight. To
  specify these parameters, add a call to stroke()
  and strokeWeight() just before the end of the
  draw() loop. By default, the grid will run through
  the origin (0,0,0) of the sketch along the XZ
  plane and the axes icon will be offset from the
  origin. Both the grid and axes icon will be sized
  according to the current canvas size. Note that
  because the grid runs parallel to the default
  camera view, it is often helpful to use debugMode
  along with orbitControl to allow full view of the
  grid.

*Sub-module: interaction*

---

### debugMode

*   debugMode() helps visualize 3D space by adding a
  grid to indicate where the â€˜groundâ€™ is in a sketch
  and an axes icon which indicates the +X, +Y, and
  +Z directions. This function can be called without
  parameters to create a default grid and axes icon,
  or it can be called according to the examples
  above to customize the size and position of the
  grid and/or axes icon. The grid is drawn using the
  most recently set stroke color and weight. To
  specify these parameters, add a call to stroke()
  and strokeWeight() just before the end of the
  draw() loop. By default, the grid will run through
  the origin (0,0,0) of the sketch along the XZ
  plane and the axes icon will be offset from the
  origin. Both the grid and axes icon will be sized
  according to the current canvas size. Note that
  because the grid runs parallel to the default
  camera view, it is often helpful to use debugMode
  along with orbitControl to allow full view of the
  grid.
  - **mode**: either GRID or AXES

*Sub-module: interaction*

---

### debugMode

*   debugMode() helps visualize 3D space by adding a
  grid to indicate where the â€˜groundâ€™ is in a sketch
  and an axes icon which indicates the +X, +Y, and
  +Z directions. This function can be called without
  parameters to create a default grid and axes icon,
  or it can be called according to the examples
  above to customize the size and position of the
  grid and/or axes icon. The grid is drawn using the
  most recently set stroke color and weight. To
  specify these parameters, add a call to stroke()
  and strokeWeight() just before the end of the
  draw() loop. By default, the grid will run through
  the origin (0,0,0) of the sketch along the XZ
  plane and the axes icon will be offset from the
  origin. Both the grid and axes icon will be sized
  according to the current canvas size. Note that
  because the grid runs parallel to the default
  camera view, it is often helpful to use debugMode
  along with orbitControl to allow full view of the
  grid.
  - **mode**: either GRID or AXES
  @param [gridSize] size of one side of the grid
  @param [gridDivisions] number of divisions in the
  grid
  @param [xOff] X axis offset from origin (0,0,0)
  @param [yOff] Y axis offset from origin (0,0,0)
  @param [zOff] Z axis offset from origin (0,0,0)

*Sub-module: interaction*

---

### debugMode

*   debugMode() helps visualize 3D space by adding a
  grid to indicate where the â€˜groundâ€™ is in a sketch
  and an axes icon which indicates the +X, +Y, and
  +Z directions. This function can be called without
  parameters to create a default grid and axes icon,
  or it can be called according to the examples
  above to customize the size and position of the
  grid and/or axes icon. The grid is drawn using the
  most recently set stroke color and weight. To
  specify these parameters, add a call to stroke()
  and strokeWeight() just before the end of the
  draw() loop. By default, the grid will run through
  the origin (0,0,0) of the sketch along the XZ
  plane and the axes icon will be offset from the
  origin. Both the grid and axes icon will be sized
  according to the current canvas size. Note that
  because the grid runs parallel to the default
  camera view, it is often helpful to use debugMode
  along with orbitControl to allow full view of the
  grid.
  - **mode**: either GRID or AXES
  @param [axesSize] size of axes icon
  @param [xOff] X axis offset from origin (0,0,0)
  @param [yOff] Y axis offset from origin (0,0,0)
  @param [zOff] Z axis offset from origin (0,0,0)

*Sub-module: interaction*

---

### debugMode

*   debugMode() helps visualize 3D space by adding a
  grid to indicate where the â€˜groundâ€™ is in a sketch
  and an axes icon which indicates the +X, +Y, and
  +Z directions. This function can be called without
  parameters to create a default grid and axes icon,
  or it can be called according to the examples
  above to customize the size and position of the
  grid and/or axes icon. The grid is drawn using the
  most recently set stroke color and weight. To
  specify these parameters, add a call to stroke()
  and strokeWeight() just before the end of the
  draw() loop. By default, the grid will run through
  the origin (0,0,0) of the sketch along the XZ
  plane and the axes icon will be offset from the
  origin. Both the grid and axes icon will be sized
  according to the current canvas size. Note that
  because the grid runs parallel to the default
  camera view, it is often helpful to use debugMode
  along with orbitControl to allow full view of the
  grid.
  @param [gridSize] size of one side of the grid
  @param [gridDivisions] number of divisions in the
  grid
  @param [axesSize] size of axes icon

*Sub-module: interaction*

---

### debugMode

*   Turns off debugMode() in a 3D sketch.

*Sub-module: interaction*

---

### called

*   Creates an ambient light with the given color.
  Ambient light does not come from a specific
  direction. Objects are evenly lit from all sides.
  Ambient lights are almost always used in
  combination with other types of lights.
         *   Note: lights need to be called (whether directly
  or indirectly) within draw() to remain persistent
  in a looping program. Placing them in setup() will
  cause them to only have an effect the first time
  through the loop.
  - **v1**: red or hue value relative to the current
  color range
  - **v2**: green or saturation value relative to
  the current color range
  - **v3**: blue or brightness value relative to the
  current color range
  @param [alpha] alpha value relative to current
  color range (default is 0-255)
  @chainable

*Sub-module: light*

---

### called

*   Creates an ambient light with the given color.
  Ambient light does not come from a specific
  direction. Objects are evenly lit from all sides.
  Ambient lights are almost always used in
  combination with other types of lights.
         *   Note: lights need to be called (whether directly
  or indirectly) within draw() to remain persistent
  in a looping program. Placing them in setup() will
  cause them to only have an effect the first time
  through the loop.
  - **gray**: number specifying value between white
  and black
  @param [alpha] alpha value relative to current
  color range (default is 0-255)
  @chainable

*Sub-module: light*

---

### called

*   Creates an ambient light with the given color.
  Ambient light does not come from a specific
  direction. Objects are evenly lit from all sides.
  Ambient lights are almost always used in
  combination with other types of lights.
         *   Note: lights need to be called (whether directly
  or indirectly) within draw() to remain persistent
  in a looping program. Placing them in setup() will
  cause them to only have an effect the first time
  through the loop.
  - **value**: a color string
  @chainable

*Sub-module: light*

---

### called

*   Creates an ambient light with the given color.
  Ambient light does not come from a specific
  direction. Objects are evenly lit from all sides.
  Ambient lights are almost always used in
  combination with other types of lights.
         *   Note: lights need to be called (whether directly
  or indirectly) within draw() to remain persistent
  in a looping program. Placing them in setup() will
  cause them to only have an effect the first time
  through the loop.
  - **values**: an array containing the
  red,green,blue & and alpha components of the color
  @chainable

*Sub-module: light*

---

### called

*   Creates an ambient light with the given color.
  Ambient light does not come from a specific
  direction. Objects are evenly lit from all sides.
  Ambient lights are almost always used in
  combination with other types of lights.
         *   Note: lights need to be called (whether directly
  or indirectly) within draw() to remain persistent
  in a looping program. Placing them in setup() will
  cause them to only have an effect the first time
  through the loop.
  - **color**: color as a p5.Color
  @chainable

*Sub-module: light*

---

### light

*   Sets the color of the specular highlight of a
  non-ambient light (i.e. all lights except
  ambientLight()). specularColor() affects only the
  lights which are created after it in the code.
         *   This function is used in combination with
  specularMaterial(). If a geometry does not use
  specularMaterial(), this function will have no
  effect.
         *   The default color is white (255, 255, 255), which
  is used if specularColor() is not explicitly
  called.
         *   Note: specularColor is equivalent to the
  Processing function lightSpecular.
  - **v1**: red or hue value relative to the current
  color range
  - **v2**: green or saturation value relative to
  the current color range
  - **v3**: blue or brightness value relative to the
  current color range
  @chainable

*Sub-module: light*

---

### light

*   Sets the color of the specular highlight of a
  non-ambient light (i.e. all lights except
  ambientLight()). specularColor() affects only the
  lights which are created after it in the code.
         *   This function is used in combination with
  specularMaterial(). If a geometry does not use
  specularMaterial(), this function will have no
  effect.
         *   The default color is white (255, 255, 255), which
  is used if specularColor() is not explicitly
  called.
         *   Note: specularColor is equivalent to the
  Processing function lightSpecular.
  - **gray**: number specifying value between white
  and black
  @chainable

*Sub-module: light*

---

### light

*   Sets the color of the specular highlight of a
  non-ambient light (i.e. all lights except
  ambientLight()). specularColor() affects only the
  lights which are created after it in the code.
         *   This function is used in combination with
  specularMaterial(). If a geometry does not use
  specularMaterial(), this function will have no
  effect.
         *   The default color is white (255, 255, 255), which
  is used if specularColor() is not explicitly
  called.
         *   Note: specularColor is equivalent to the
  Processing function lightSpecular.
  - **value**: color as a CSS string
  @chainable

*Sub-module: light*

---

### light

*   Sets the color of the specular highlight of a
  non-ambient light (i.e. all lights except
  ambientLight()). specularColor() affects only the
  lights which are created after it in the code.
         *   This function is used in combination with
  specularMaterial(). If a geometry does not use
  specularMaterial(), this function will have no
  effect.
         *   The default color is white (255, 255, 255), which
  is used if specularColor() is not explicitly
  called.
         *   Note: specularColor is equivalent to the
  Processing function lightSpecular.
  - **values**: color as an array containing the
  red, green, and blue components
  @chainable

*Sub-module: light*

---

### light

*   Sets the color of the specular highlight of a
  non-ambient light (i.e. all lights except
  ambientLight()). specularColor() affects only the
  lights which are created after it in the code.
         *   This function is used in combination with
  specularMaterial(). If a geometry does not use
  specularMaterial(), this function will have no
  effect.
         *   The default color is white (255, 255, 255), which
  is used if specularColor() is not explicitly
  called.
         *   Note: specularColor is equivalent to the
  Processing function lightSpecular.
  - **color**: color as a p5.Color
  @chainable

*Sub-module: light*

---

### as

*   Creates a directional light with the given color
  and direction. Directional light comes from one
  direction. The direction is specified as numbers
  inclusively between -1 and 1. For example, setting
  the direction as (0, -1, 0) will cause the
  geometry to be lit from below (since the light
  will be facing directly upwards). Similarly,
  setting the direction as (1, 0, 0) will cause the
  geometry to be lit from the left (since the light
  will be facing directly rightwards).
         *   Directional lights do not have a specific point of
  origin, and therefore cannot be positioned closer
  or farther away from a geometry.
         *   A maximum of 5 directional lights can be active at
  once.
         *   Note: lights need to be called (whether directly
  or indirectly) within draw() to remain persistent
  in a looping program. Placing them in setup() will
  cause them to only have an effect the first time
  through the loop.
  - **v1**: red or hue value relative to the current
  color range
  - **v2**: green or saturation value relative to
  the current color range
  - **v3**: blue or brightness value relative to the
  current color range
  - **x**: x component of direction (inclusive range
  of -1 to 1)
  - **y**: y component of direction (inclusive range
  of -1 to 1)
  - **z**: z component of direction (inclusive range
  of -1 to 1)
  @chainable

*Sub-module: light*

---

### as

*   Creates a directional light with the given color
  and direction. Directional light comes from one
  direction. The direction is specified as numbers
  inclusively between -1 and 1. For example, setting
  the direction as (0, -1, 0) will cause the
  geometry to be lit from below (since the light
  will be facing directly upwards). Similarly,
  setting the direction as (1, 0, 0) will cause the
  geometry to be lit from the left (since the light
  will be facing directly rightwards).
         *   Directional lights do not have a specific point of
  origin, and therefore cannot be positioned closer
  or farther away from a geometry.
         *   A maximum of 5 directional lights can be active at
  once.
         *   Note: lights need to be called (whether directly
  or indirectly) within draw() to remain persistent
  in a looping program. Placing them in setup() will
  cause them to only have an effect the first time
  through the loop.
  - **v1**: red or hue value relative to the current
  color range
  - **v2**: green or saturation value relative to
  the current color range
  - **v3**: blue or brightness value relative to the
  current color range
  - **direction**: direction of light as a p5.Vector
  @chainable

*Sub-module: light*

---

### as

*   Creates a directional light with the given color
  and direction. Directional light comes from one
  direction. The direction is specified as numbers
  inclusively between -1 and 1. For example, setting
  the direction as (0, -1, 0) will cause the
  geometry to be lit from below (since the light
  will be facing directly upwards). Similarly,
  setting the direction as (1, 0, 0) will cause the
  geometry to be lit from the left (since the light
  will be facing directly rightwards).
         *   Directional lights do not have a specific point of
  origin, and therefore cannot be positioned closer
  or farther away from a geometry.
         *   A maximum of 5 directional lights can be active at
  once.
         *   Note: lights need to be called (whether directly
  or indirectly) within draw() to remain persistent
  in a looping program. Placing them in setup() will
  cause them to only have an effect the first time
  through the loop.
  - **color**: color as a p5.Color, as an array, or
  as a CSS string
  - **x**: x component of direction (inclusive range
  of -1 to 1)
  - **y**: y component of direction (inclusive range
  of -1 to 1)
  - **z**: z component of direction (inclusive range
  of -1 to 1)
  @chainable

*Sub-module: light*

---

### as

*   Creates a directional light with the given color
  and direction. Directional light comes from one
  direction. The direction is specified as numbers
  inclusively between -1 and 1. For example, setting
  the direction as (0, -1, 0) will cause the
  geometry to be lit from below (since the light
  will be facing directly upwards). Similarly,
  setting the direction as (1, 0, 0) will cause the
  geometry to be lit from the left (since the light
  will be facing directly rightwards).
         *   Directional lights do not have a specific point of
  origin, and therefore cannot be positioned closer
  or farther away from a geometry.
         *   A maximum of 5 directional lights can be active at
  once.
         *   Note: lights need to be called (whether directly
  or indirectly) within draw() to remain persistent
  in a looping program. Placing them in setup() will
  cause them to only have an effect the first time
  through the loop.
  - **color**: color as a p5.Color, as an array, or
  as a CSS string
  - **direction**: direction of light as a p5.Vector
  @chainable

*Sub-module: light*

---

### point

*   Creates a point light with the given color and
  position. A point light emits light from a single
  point in all directions. Because the light is
  emitted from a specific point (position), it has a
  different effect when it is positioned farther vs.
  nearer an object.
         *   A maximum of 5 point lights can be active at once.
         *   Note: lights need to be called (whether directly
  or indirectly) within draw() to remain persistent
  in a looping program. Placing them in setup() will
  cause them to only have an effect the first time
  through the loop.
  - **v1**: red or hue value relative to the current
  color range
  - **v2**: green or saturation value relative to
  the current color range
  - **v3**: blue or brightness value relative to the
  current color range
  - **x**: x component of position
  - **y**: y component of position
  - **z**: z component of position
  @chainable

*Sub-module: light*

---

### point

*   Creates a point light with the given color and
  position. A point light emits light from a single
  point in all directions. Because the light is
  emitted from a specific point (position), it has a
  different effect when it is positioned farther vs.
  nearer an object.
         *   A maximum of 5 point lights can be active at once.
         *   Note: lights need to be called (whether directly
  or indirectly) within draw() to remain persistent
  in a looping program. Placing them in setup() will
  cause them to only have an effect the first time
  through the loop.
  - **v1**: red or hue value relative to the current
  color range
  - **v2**: green or saturation value relative to
  the current color range
  - **v3**: blue or brightness value relative to the
  current color range
  - **position**: of light as a p5.Vector
  @chainable

*Sub-module: light*

---

### point

*   Creates a point light with the given color and
  position. A point light emits light from a single
  point in all directions. Because the light is
  emitted from a specific point (position), it has a
  different effect when it is positioned farther vs.
  nearer an object.
         *   A maximum of 5 point lights can be active at once.
         *   Note: lights need to be called (whether directly
  or indirectly) within draw() to remain persistent
  in a looping program. Placing them in setup() will
  cause them to only have an effect the first time
  through the loop.
  - **color**: color as a p5.Color, as an array, or
  as a CSS string
  - **x**: x component of position
  - **y**: y component of position
  - **z**: z component of position
  @chainable

*Sub-module: light*

---

### point

*   Creates a point light with the given color and
  position. A point light emits light from a single
  point in all directions. Because the light is
  emitted from a specific point (position), it has a
  different effect when it is positioned farther vs.
  nearer an object.
         *   A maximum of 5 point lights can be active at once.
         *   Note: lights need to be called (whether directly
  or indirectly) within draw() to remain persistent
  in a looping program. Placing them in setup() will
  cause them to only have an effect the first time
  through the loop.
  - **color**: color as a p5.Color, as an array, or
  as a CSS string
  - **position**: of light as a p5.Vector
  @chainable

*Sub-module: light*

---

### ambientLight

*   Places an ambient and directional light in the
  scene. The lights are set to ambientLight(128,
  128, 128) and directionalLight(128, 128, 128, 0,
  0, -1). Note: lights need to be called (whether
  directly or indirectly) within draw() to remain
  persistent in a looping program. Placing them in
  setup() will cause them to only have an effect the
  first time through the loop.
  @chainable

*Sub-module: light*

---

### pointLight

*   Sets the falloff rate for pointLight() and
  spotLight(). lightFalloff() affects only the
  lights which are created after it in the code.
         *   The constant, linear, an quadratic parameters are
  used to calculate falloff as follows:
         *   d = distance from light position to vertex
  position
         *   falloff = 1 / (CONSTANT + d * LINEAR + (d * d) *
  QUADRATIC)
  - **constant**: CONSTANT value for determining
  falloff
  - **linear**: LINEAR value for determining falloff
  - **quadratic**: QUADRATIC value for determining
  falloff
  @chainable

*Sub-module: light*

---

### pointLight

*   Creates a spot light with the given color,
  position, light direction, angle, and
  concentration. Like a pointLight(), a spotLight()
  emits light from a specific point (position). It
  has a different effect when it is positioned
  farther vs. nearer an object.
         *   However, unlike a pointLight(), the light is
  emitted in one direction along a conical shape.
  The shape of the cone can be controlled using the
  angle and concentration parameters.
         *   The angle parameter is used to determine the
  radius of the cone. And the concentration
  parameter is used to focus the light towards the
  center of the cone. Both parameters are optional,
  however if you want to specify concentration, you
  must also specify angle. The minimum concentration
  value is 1.
         *   A maximum of 5 spot lights can be active at once.
         *   Note: lights need to be called (whether directly
  or indirectly) within draw() to remain persistent
  in a looping program. Placing them in setup() will
  cause them to only have an effect the first time
  through the loop.
  - **v1**: red or hue value relative to the current
  color range
  - **v2**: green or saturation value relative to
  the current color range
  - **v3**: blue or brightness value relative to the
  current color range
  - **x**: x component of position
  - **y**: y component of position
  - **z**: z component of position
  - **rx**: x component of light direction
  (inclusive range of -1 to 1)
  - **ry**: y component of light direction
  (inclusive range of -1 to 1)
  - **rz**: z component of light direction
  (inclusive range of -1 to 1)
  @param [angle] angle of cone. Defaults to PI/3
  @param [concentration] concentration of cone.
  Defaults to 100
  @chainable

*Sub-module: light*

---

### pointLight

*   Creates a spot light with the given color,
  position, light direction, angle, and
  concentration. Like a pointLight(), a spotLight()
  emits light from a specific point (position). It
  has a different effect when it is positioned
  farther vs. nearer an object.
         *   However, unlike a pointLight(), the light is
  emitted in one direction along a conical shape.
  The shape of the cone can be controlled using the
  angle and concentration parameters.
         *   The angle parameter is used to determine the
  radius of the cone. And the concentration
  parameter is used to focus the light towards the
  center of the cone. Both parameters are optional,
  however if you want to specify concentration, you
  must also specify angle. The minimum concentration
  value is 1.
         *   A maximum of 5 spot lights can be active at once.
         *   Note: lights need to be called (whether directly
  or indirectly) within draw() to remain persistent
  in a looping program. Placing them in setup() will
  cause them to only have an effect the first time
  through the loop.
  - **color**: color as a p5.Color, as an array, or
  as a CSS string
  - **position**: position of light as a p5.Vector
  - **direction**: direction of light as a p5.Vector
  @param [angle] angle of cone. Defaults to PI/3
  @param [concentration] concentration of cone.
  Defaults to 100

*Sub-module: light*

---

### pointLight

*   Creates a spot light with the given color,
  position, light direction, angle, and
  concentration. Like a pointLight(), a spotLight()
  emits light from a specific point (position). It
  has a different effect when it is positioned
  farther vs. nearer an object.
         *   However, unlike a pointLight(), the light is
  emitted in one direction along a conical shape.
  The shape of the cone can be controlled using the
  angle and concentration parameters.
         *   The angle parameter is used to determine the
  radius of the cone. And the concentration
  parameter is used to focus the light towards the
  center of the cone. Both parameters are optional,
  however if you want to specify concentration, you
  must also specify angle. The minimum concentration
  value is 1.
         *   A maximum of 5 spot lights can be active at once.
         *   Note: lights need to be called (whether directly
  or indirectly) within draw() to remain persistent
  in a looping program. Placing them in setup() will
  cause them to only have an effect the first time
  through the loop.
  - **v1**: red or hue value relative to the current
  color range
  - **v2**: green or saturation value relative to
  the current color range
  - **v3**: blue or brightness value relative to the
  current color range
  - **position**: position of light as a p5.Vector
  - **direction**: direction of light as a p5.Vector
  @param [angle] angle of cone. Defaults to PI/3
  @param [concentration] concentration of cone.
  Defaults to 100

*Sub-module: light*

---

### pointLight

*   Creates a spot light with the given color,
  position, light direction, angle, and
  concentration. Like a pointLight(), a spotLight()
  emits light from a specific point (position). It
  has a different effect when it is positioned
  farther vs. nearer an object.
         *   However, unlike a pointLight(), the light is
  emitted in one direction along a conical shape.
  The shape of the cone can be controlled using the
  angle and concentration parameters.
         *   The angle parameter is used to determine the
  radius of the cone. And the concentration
  parameter is used to focus the light towards the
  center of the cone. Both parameters are optional,
  however if you want to specify concentration, you
  must also specify angle. The minimum concentration
  value is 1.
         *   A maximum of 5 spot lights can be active at once.
         *   Note: lights need to be called (whether directly
  or indirectly) within draw() to remain persistent
  in a looping program. Placing them in setup() will
  cause them to only have an effect the first time
  through the loop.
  - **color**: color as a p5.Color, as an array, or
  as a CSS string
  - **x**: x component of position
  - **y**: y component of position
  - **z**: z component of position
  - **direction**: direction of light as a p5.Vector
  @param [angle] angle of cone. Defaults to PI/3
  @param [concentration] concentration of cone.
  Defaults to 100

*Sub-module: light*

---

### pointLight

*   Creates a spot light with the given color,
  position, light direction, angle, and
  concentration. Like a pointLight(), a spotLight()
  emits light from a specific point (position). It
  has a different effect when it is positioned
  farther vs. nearer an object.
         *   However, unlike a pointLight(), the light is
  emitted in one direction along a conical shape.
  The shape of the cone can be controlled using the
  angle and concentration parameters.
         *   The angle parameter is used to determine the
  radius of the cone. And the concentration
  parameter is used to focus the light towards the
  center of the cone. Both parameters are optional,
  however if you want to specify concentration, you
  must also specify angle. The minimum concentration
  value is 1.
         *   A maximum of 5 spot lights can be active at once.
         *   Note: lights need to be called (whether directly
  or indirectly) within draw() to remain persistent
  in a looping program. Placing them in setup() will
  cause them to only have an effect the first time
  through the loop.
  - **color**: color as a p5.Color, as an array, or
  as a CSS string
  - **position**: position of light as a p5.Vector
  - **rx**: x component of light direction
  (inclusive range of -1 to 1)
  - **ry**: y component of light direction
  (inclusive range of -1 to 1)
  - **rz**: z component of light direction
  (inclusive range of -1 to 1)
  @param [angle] angle of cone. Defaults to PI/3
  @param [concentration] concentration of cone.
  Defaults to 100

*Sub-module: light*

---

### pointLight

*   Creates a spot light with the given color,
  position, light direction, angle, and
  concentration. Like a pointLight(), a spotLight()
  emits light from a specific point (position). It
  has a different effect when it is positioned
  farther vs. nearer an object.
         *   However, unlike a pointLight(), the light is
  emitted in one direction along a conical shape.
  The shape of the cone can be controlled using the
  angle and concentration parameters.
         *   The angle parameter is used to determine the
  radius of the cone. And the concentration
  parameter is used to focus the light towards the
  center of the cone. Both parameters are optional,
  however if you want to specify concentration, you
  must also specify angle. The minimum concentration
  value is 1.
         *   A maximum of 5 spot lights can be active at once.
         *   Note: lights need to be called (whether directly
  or indirectly) within draw() to remain persistent
  in a looping program. Placing them in setup() will
  cause them to only have an effect the first time
  through the loop.
  - **v1**: red or hue value relative to the current
  color range
  - **v2**: green or saturation value relative to
  the current color range
  - **v3**: blue or brightness value relative to the
  current color range
  - **x**: x component of position
  - **y**: y component of position
  - **z**: z component of position
  - **direction**: direction of light as a p5.Vector
  @param [angle] angle of cone. Defaults to PI/3
  @param [concentration] concentration of cone.
  Defaults to 100

*Sub-module: light*

---

### pointLight

*   Creates a spot light with the given color,
  position, light direction, angle, and
  concentration. Like a pointLight(), a spotLight()
  emits light from a specific point (position). It
  has a different effect when it is positioned
  farther vs. nearer an object.
         *   However, unlike a pointLight(), the light is
  emitted in one direction along a conical shape.
  The shape of the cone can be controlled using the
  angle and concentration parameters.
         *   The angle parameter is used to determine the
  radius of the cone. And the concentration
  parameter is used to focus the light towards the
  center of the cone. Both parameters are optional,
  however if you want to specify concentration, you
  must also specify angle. The minimum concentration
  value is 1.
         *   A maximum of 5 spot lights can be active at once.
         *   Note: lights need to be called (whether directly
  or indirectly) within draw() to remain persistent
  in a looping program. Placing them in setup() will
  cause them to only have an effect the first time
  through the loop.
  - **v1**: red or hue value relative to the current
  color range
  - **v2**: green or saturation value relative to
  the current color range
  - **v3**: blue or brightness value relative to the
  current color range
  - **position**: position of light as a p5.Vector
  - **rx**: x component of light direction
  (inclusive range of -1 to 1)
  - **ry**: y component of light direction
  (inclusive range of -1 to 1)
  - **rz**: z component of light direction
  (inclusive range of -1 to 1)
  @param [angle] angle of cone. Defaults to PI/3
  @param [concentration] concentration of cone.
  Defaults to 100

*Sub-module: light*

---

### pointLight

*   Creates a spot light with the given color,
  position, light direction, angle, and
  concentration. Like a pointLight(), a spotLight()
  emits light from a specific point (position). It
  has a different effect when it is positioned
  farther vs. nearer an object.
         *   However, unlike a pointLight(), the light is
  emitted in one direction along a conical shape.
  The shape of the cone can be controlled using the
  angle and concentration parameters.
         *   The angle parameter is used to determine the
  radius of the cone. And the concentration
  parameter is used to focus the light towards the
  center of the cone. Both parameters are optional,
  however if you want to specify concentration, you
  must also specify angle. The minimum concentration
  value is 1.
         *   A maximum of 5 spot lights can be active at once.
         *   Note: lights need to be called (whether directly
  or indirectly) within draw() to remain persistent
  in a looping program. Placing them in setup() will
  cause them to only have an effect the first time
  through the loop.
  - **color**: color as a p5.Color, as an array, or
  as a CSS string
  - **x**: x component of position
  - **y**: y component of position
  - **z**: z component of position
  - **rx**: x component of light direction
  (inclusive range of -1 to 1)
  - **ry**: y component of light direction
  (inclusive range of -1 to 1)
  - **rz**: z component of light direction
  (inclusive range of -1 to 1)
  @param [angle] angle of cone. Defaults to PI/3
  @param [concentration] concentration of cone.
  Defaults to 100

*Sub-module: light*

---

### functions

*   Removes all lights present in a sketch. All
  subsequent geometry is rendered without lighting
  (until a new light is created with a call to one
  of the lighting functions (lights(),
  ambientLight(), directionalLight(), pointLight(),
  spotLight()).
  @chainable

*Sub-module: light*

---

### loadModel

*   Load a 3d model from an OBJ or STL file.
  loadModel() should be placed inside of preload().
  This allows the model to load fully before the
  rest of your code is run.
         *   One of the limitations of the OBJ and STL format
  is that it doesn't have a built-in sense of scale.
  This means that models exported from different
  programs might be very different sizes. If your
  model isn't displaying, try calling loadModel()
  with the normalized parameter set to true. This
  will resize the model to a scale appropriate for
  p5. You can also make additional changes to the
  final size of your model with the scale()
  function.
         *   Also, the support for colored STL files is not
  present. STL files with color will be rendered
  without color properties.
  - **path**: Path of the model to be loaded
  - **normalize**: If true, scale the model to a
  standardized size when loading
  @param [successCallback] Function to be called
  once the model is loaded. Will be passed the 3D
  model object.
  @param [failureCallback] called with event error
  if the model fails to load.
  @param [fileType] The file extension of the model
  (.stl, .obj).
  - **Returns**: the p5.Geometry object

*Sub-module: loading*

---

### preload

*   Creates a new p5.Shader object from the provided
  vertex and fragment shader files. The shader files
  are loaded asynchronously in the background, so
  this method should be used in preload().
         *   Note, shaders can only be used in WEBGL mode.
  - **vertFilename**: path to file containing vertex
  shader source code
  - **fragFilename**: path to file containing
  fragment shader source code
  @param [callback] callback to be executed after
  loadShader completes. On success, the p5.Shader
  object is passed as the first argument.
  @param [errorCallback] callback to be executed
  when an error occurs inside loadShader. On error,
  the error is passed as the first argument.
  - **Returns**: a shader object created from the provided
  vertex and fragment shader files.

*Sub-module: material*

---

### createShader

*   Sets the p5.Shader object to be used to render
  subsequent shapes. Custom shaders can be created
  using the createShader() and loadShader()
  functions.
         *   Use resetShader() to restore the default shaders.
         *   Note, shaders can only be used in WEBGL mode.
  - **s**: the p5.Shader object to use for rendering
  shapes.
  @chainable

*Sub-module: material*

---

### resetShader

*   Restores the default shaders. Code that runs after
  resetShader() will not be affected by the shader
  previously set by shader()
  @chainable

*Sub-module: material*

---

### beginShape

*   Sets the texture that will be used to render
  subsequent shapes. A texture is like a "skin" that
  wraps around a 3D geometry. Currently supported
  textures are images, video, and offscreen renders.
         *   To texture a geometry created with beginShape(),
  you will need to specify uv coordinates in
  vertex().
         *   Note, texture() can only be used in WEBGL mode.
         *   You can view more materials in this example.
  - **tex**: image to use as texture
  @chainable

*Sub-module: material*

---

### points

*   Sets the coordinate space for texture mapping. The
  default mode is IMAGE which refers to the actual
  coordinates of the image. NORMAL refers to a
  normalized space of values ranging from 0 to 1.
  With IMAGE, if an image is 100Ã—200 pixels, mapping
  the image onto the entire size of a quad would
  require the points (0,0) (100, 0) (100,200)
  (0,200). The same mapping in NORMAL is (0,0) (1,0)
  (1,1) (0,1).
  - **mode**: either IMAGE or NORMAL

*Sub-module: material*

---

### size

*   Sets the global texture wrapping mode. This
  controls how textures behave when their uv's go
  outside of the 0 to 1 range. There are three
  options: CLAMP, REPEAT, and MIRROR. CLAMP causes
  the pixels at the edge of the texture to extend to
  the bounds. REPEAT causes the texture to tile
  repeatedly until reaching the bounds. MIRROR works
  similarly to REPEAT but it flips the texture with
  every new tile.
         *   REPEAT & MIRROR are only available if the texture
  is a power of two size (128, 256, 512, 1024,
  etc.).
         *   This method will affect all textures in your
  sketch until a subsequent textureWrap() call is
  made.
         *   If only one argument is provided, it will be
  applied to both the horizontal and vertical axes.
  - **wrapX**: either CLAMP, REPEAT, or MIRROR
  @param [wrapY] either CLAMP, REPEAT, or MIRROR

*Sub-module: material*

---

### normalMaterial

*   Sets the current material as a normal material. A
  normal material is not affected by light. It is
  often used as a placeholder material when
  debugging.
         *   Surfaces facing the X-axis become red, those
  facing the Y-axis become green, and those facing
  the Z-axis become blue.
         *   You can view more materials in this example.
  @chainable

*Sub-module: material*

---

### ambientMaterial

*   Sets the ambient color of the material. The
  ambientMaterial() color represents the components
  of the ambientLight() color that the object
  reflects.
         *   Consider an ambientMaterial() with the color
  yellow (255, 255, 0). If the ambientLight() emits
  the color white (255, 255, 255), then the object
  will appear yellow as it will reflect the red and
  green components of the light. If the
  ambientLight() emits the color red (255, 0, 0),
  then the object will appear red as it will reflect
  the red component of the light. If the
  ambientLight() emits the color blue (0, 0, 255),
  then the object will appear black, as there is no
  component of the light that it can reflect.
         *   You can view more materials in this example.
  - **v1**: red or hue value relative to the current
  color range
  - **v2**: green or saturation value relative to
  the current color range
  - **v3**: blue or brightness value relative to the
  current color range
  @chainable

*Sub-module: material*

---

### ambientMaterial

*   Sets the ambient color of the material. The
  ambientMaterial() color represents the components
  of the ambientLight() color that the object
  reflects.
         *   Consider an ambientMaterial() with the color
  yellow (255, 255, 0). If the ambientLight() emits
  the color white (255, 255, 255), then the object
  will appear yellow as it will reflect the red and
  green components of the light. If the
  ambientLight() emits the color red (255, 0, 0),
  then the object will appear red as it will reflect
  the red component of the light. If the
  ambientLight() emits the color blue (0, 0, 255),
  then the object will appear black, as there is no
  component of the light that it can reflect.
         *   You can view more materials in this example.
  - **gray**: number specifying value between white
  and black
  @chainable

*Sub-module: material*

---

### ambientMaterial

*   Sets the ambient color of the material. The
  ambientMaterial() color represents the components
  of the ambientLight() color that the object
  reflects.
         *   Consider an ambientMaterial() with the color
  yellow (255, 255, 0). If the ambientLight() emits
  the color white (255, 255, 255), then the object
  will appear yellow as it will reflect the red and
  green components of the light. If the
  ambientLight() emits the color red (255, 0, 0),
  then the object will appear red as it will reflect
  the red component of the light. If the
  ambientLight() emits the color blue (0, 0, 255),
  then the object will appear black, as there is no
  component of the light that it can reflect.
         *   You can view more materials in this example.
  - **color**: color as a p5.Color, as an array, or
  as a CSS string
  @chainable

*Sub-module: material*

---

### range

*   Sets the emissive color of the material. An
  emissive material will display the emissive color
  at full strength regardless of lighting. This can
  give the appearance that the object is glowing.
         *   Note, "emissive" is a misnomer in the sense that
  the material does not actually emit light that
  will affect surrounding objects.
         *   You can view more materials in this example.
  - **v1**: red or hue value relative to the current
  color range
  - **v2**: green or saturation value relative to
  the current color range
  - **v3**: blue or brightness value relative to the
  current color range
  @param [alpha] alpha value relative to current
  color range (default is 0-255)
  @chainable

*Sub-module: material*

---

### emissiveMaterial

*   Sets the emissive color of the material. An
  emissive material will display the emissive color
  at full strength regardless of lighting. This can
  give the appearance that the object is glowing.
         *   Note, "emissive" is a misnomer in the sense that
  the material does not actually emit light that
  will affect surrounding objects.
         *   You can view more materials in this example.
  - **gray**: number specifying value between white
  and black
  @chainable

*Sub-module: material*

---

### emissiveMaterial

*   Sets the emissive color of the material. An
  emissive material will display the emissive color
  at full strength regardless of lighting. This can
  give the appearance that the object is glowing.
         *   Note, "emissive" is a misnomer in the sense that
  the material does not actually emit light that
  will affect surrounding objects.
         *   You can view more materials in this example.
  - **color**: color as a p5.Color, as an array, or
  as a CSS string
  @chainable

*Sub-module: material*

---

### reflective

*   Sets the specular color of the material. A
  specular material is reflective (shiny). The
  shininess can be controlled by the shininess()
  function.
         *   Like ambientMaterial(), the specularMaterial()
  color is the color the object will reflect under
  ambientLight(). However unlike ambientMaterial(),
  for all other types of lights (directionalLight(),
  pointLight(), spotLight()), a specular material
  will reflect the color of the light source. This
  is what gives it its "shiny" appearance.
         *   You can view more materials in this example.
  - **gray**: number specifying value between white
  and black.
  @param [alpha] alpha value relative to current
  color range (default is 0-255)
  @chainable

*Sub-module: material*

---

### reflective

*   Sets the specular color of the material. A
  specular material is reflective (shiny). The
  shininess can be controlled by the shininess()
  function.
         *   Like ambientMaterial(), the specularMaterial()
  color is the color the object will reflect under
  ambientLight(). However unlike ambientMaterial(),
  for all other types of lights (directionalLight(),
  pointLight(), spotLight()), a specular material
  will reflect the color of the light source. This
  is what gives it its "shiny" appearance.
         *   You can view more materials in this example.
  - **v1**: red or hue value relative to the current
  color range
  - **v2**: green or saturation value relative to
  the current color range
  - **v3**: blue or brightness value relative to the
  current color range
  @param [alpha] alpha value relative to current
  color range (default is 0-255)
  @chainable

*Sub-module: material*

---

### reflective

*   Sets the specular color of the material. A
  specular material is reflective (shiny). The
  shininess can be controlled by the shininess()
  function.
         *   Like ambientMaterial(), the specularMaterial()
  color is the color the object will reflect under
  ambientLight(). However unlike ambientMaterial(),
  for all other types of lights (directionalLight(),
  pointLight(), spotLight()), a specular material
  will reflect the color of the light source. This
  is what gives it its "shiny" appearance.
         *   You can view more materials in this example.
  - **color**: color as a p5.Color, as an array, or
  as a CSS string
  @chainable

*Sub-module: material*

---

### gloss

*   Sets the amount of gloss ("shininess") of a
  specularMaterial(). The default and minimum value
  is 1.
  - **shine**: degree of shininess
  @chainable

*Sub-module: material*

---

### perspective

*   Sets a perspective projection. Accepts the same
  parameters as the global perspective(). More
  information on this function can be found there.

*Sub-module: p5.Camera*

---

### ortho

*   Sets an orthographic projection. Accepts the same
  parameters as the global ortho(). More information
  on this function can be found there.

*Sub-module: p5.Camera*

---

### frustum

*   Sets the camera's frustum. Accepts the same
  parameters as the global frustum(). More
  information on this function can be found there.

*Sub-module: p5.Camera*

---

### counterclockwise

*   Panning rotates the camera view to the left and
  right.
  - **angle**: amount to rotate camera in current
  angleMode units. Greater than 0 values rotate
  counterclockwise (to the left).

*Sub-module: p5.Camera*

---

### counterclockwise

*   Tilting rotates the camera view up and down.
  - **angle**: amount to rotate camera in current
  angleMode units. Greater than 0 values rotate
  counterclockwise (to the left).

*Sub-module: p5.Camera*

---

### lookAt

*   Reorients the camera to look at a position in
  world space.
  - **x**: x position of a point in world space
  - **y**: y position of a point in world space
  - **z**: z position of a point in world space

*Sub-module: p5.Camera*

---

### camera

*   Sets the camera's position and orientation.
  Accepts the same parameters as the global
  camera(). More information on this function can be
  found there.

*Sub-module: p5.Camera*

---

### move

*   Move camera along its local axes while maintaining
  current camera orientation.
  - **x**: amount to move along camera's left-right
  axis
  - **y**: amount to move along camera's up-down
  axis
  - **z**: amount to move along camera's
  forward-backward axis

*Sub-module: p5.Camera*

---

### setPosition

*   Set camera position in world-space while
  maintaining current camera orientation.
  - **x**: x position of a point in world space
  - **y**: y position of a point in world space
  - **z**: z position of a point in world space

*Sub-module: p5.Camera*

---

### set

*   Copies information about the argument camera's
  view and projection to the target camera. If the
  target camera is active, it will be reflected on
  the screen.
  - **cam**: source camera

*Sub-module: p5.Camera*

---

### orbitControl

*   For the cameras cam0 and cam1 with the given
  arguments, their view are combined with the
  parameter amt that represents the quantity, and
  the obtained view is applied. For example, if cam0
  is looking straight ahead and cam1 is looking
  straight to the right and amt is 0.5, the applied
  camera will look to the halfway between front and
  right. If the applied camera is active, the
  applied result will be reflected on the screen.
  When applying this function, all cameras involved
  must have exactly the same projection settings.
  For example, if one is perspective, ortho,
  frustum, the other two must also be perspective,
  ortho, frustum respectively. However, if all
  cameras have ortho settings, interpolation is
  possible if the ratios of left, right, top and
  bottom are equal to each other. For example, when
  it is changed by orbitControl().
  - **cam0**: first p5.Camera
  - **cam1**: second p5.Camera
  - **amt**: amount to use for interpolation during
  slerp

*Sub-module: p5.Camera*

---

### sketch

*   camera position value on x axis

*Sub-module: p5.Camera*

---

### frustum

*   Sets a perspective projection for the current
  camera in a 3D sketch. This projection represents
  depth through foreshortening: objects that are
  close to the camera appear their actual size while
  those that are further away from the camera appear
  smaller. The parameters to this function define
  the viewing frustum (the truncated pyramid within
  which objects are seen by the camera) through
  vertical field of view, aspect ratio (usually
  width/height), and near and far clipping planes.
         *   If no parameters are given, the following default
  is used: perspective(PI/3, width/height, eyeZ/10,
  eyeZ*10), where eyeZ is equal to ((height/2) /
  tan(PI/6)).
  @param [fovy] camera frustum vertical field of
  view, from bottom to top of view, in angleMode
  units
  @param [aspect] camera frustum aspect ratio
  @param [near] frustum near plane length
  @param [far] frustum far plane length
  @chainable

*Sub-module: p5.Camera*

---

### ortho

*   Sets an orthographic projection for the current
  camera in a 3D sketch and defines a box-shaped
  viewing frustum within which objects are seen. In
  this projection, all objects with the same
  dimension appear the same size, regardless of
  whether they are near or far from the camera. The
  parameters to this function specify the viewing
  frustum where left and right are the minimum and
  maximum x values, top and bottom are the minimum
  and maximum y values, and near and far are the
  minimum and maximum z values.
         *   If no parameters are given, the following default
  is used: ortho(-width/2, width/2, -height/2,
  height/2).
  @param [left] camera frustum left plane
  @param [right] camera frustum right plane
  @param [bottom] camera frustum bottom plane
  @param [top] camera frustum top plane
  @param [near] camera frustum near plane
  @param [far] camera frustum far plane
  @chainable

*Sub-module: p5.Camera*

---

### perspective

*   Sets the frustum of the current camera as defined
  by the parameters. A frustum is a geometric form:
  a pyramid with its top cut off. With the viewer's
  eye at the imaginary top of the pyramid, the six
  planes of the frustum act as clipping planes when
  rendering a 3D view. Thus, any form inside the
  clipping planes is visible; anything outside those
  planes is not visible.
         *   Setting the frustum changes the perspective of the
  scene being rendered. This can be achieved more
  simply in many cases by using perspective().
         *   If no parameters are given, the following default
  is used: frustum(-width/20, width/20, height/20,
  -height/20, eyeZ/10, eyeZ*10), where eyeZ is equal
  to ((height/2) / tan(PI/6)).
  @param [left] camera frustum left plane
  @param [right] camera frustum right plane
  @param [bottom] camera frustum bottom plane
  @param [top] camera frustum top plane
  @param [near] camera frustum near plane
  @param [far] camera frustum far plane
  @chainable

*Sub-module: p5.Camera*

---

### current

*   Creates a new p5.Camera object and sets it as the
  current (active) camera. The new camera is
  initialized with a default position (see camera())
  and a default perspective projection (see
  perspective()). Its properties can be controlled
  with the p5.Camera methods.
         *   Note: Every 3D sketch starts with a default camera
  initialized. This camera can be controlled with
  the global methods camera(), perspective(),
  ortho(), and frustum() if it is the only camera in
  the scene.
  - **Returns**: The newly created camera object.

*Sub-module: p5.Camera*

---

### current

*   Sets the current (active) camera of a 3D sketch.
  Allows for switching between multiple cameras.
  - **cam**: p5.Camera object

*Sub-module: p5.Camera*

---

### vertexNormal

*   Sets the normal to use for subsequent vertices.
  @chainable

*Sub-module: p5.RendererGL.Immediate*

---

### false

*   Set attributes for the WebGL Drawing context. This
  is a way of adjusting how the WebGL renderer works
  to fine-tune the display and performance. Note
  that this will reinitialize the drawing context if
  called after the WebGL canvas is made.
         *   If an object is passed as the parameter, all
  attributes not declared in the object will be set
  to defaults.
         *   The available attributes are:
         *   alpha - indicates if the canvas contains an alpha
  buffer default is true
         *   depth - indicates whether the drawing buffer has a
  depth buffer of at least 16 bits - default is true
         *   stencil - indicates whether the drawing buffer has
  a stencil buffer of at least 8 bits
         *   antialias - indicates whether or not to perform
  anti-aliasing default is false (true in Safari)
         *   premultipliedAlpha - indicates that the page
  compositor will assume the drawing buffer contains
  colors with pre-multiplied alpha default is true
         *   preserveDrawingBuffer - if true the buffers will
  not be cleared and and will preserve their values
  until cleared or overwritten by author (note that
  p5 clears automatically on draw loop) default is
  true
         *   perPixelLighting - if true, per-pixel lighting
  will be used in the lighting shader otherwise
  per-vertex lighting is used. default is true.
         *   version - either 1 or 2, to specify which WebGL
  version to ask for. By default, WebGL 2 will be
  requested. If WebGL2 is not available, it will
  fall back to WebGL 1. You can check what version
  is used with by looking at the global webglVersion
  property.
  - **key**: Name of attribute
  - **value**: New value of named attribute

*Sub-module: p5.RendererGL*

---

### false

*   Set attributes for the WebGL Drawing context. This
  is a way of adjusting how the WebGL renderer works
  to fine-tune the display and performance. Note
  that this will reinitialize the drawing context if
  called after the WebGL canvas is made.
         *   If an object is passed as the parameter, all
  attributes not declared in the object will be set
  to defaults.
         *   The available attributes are:
         *   alpha - indicates if the canvas contains an alpha
  buffer default is true
         *   depth - indicates whether the drawing buffer has a
  depth buffer of at least 16 bits - default is true
         *   stencil - indicates whether the drawing buffer has
  a stencil buffer of at least 8 bits
         *   antialias - indicates whether or not to perform
  anti-aliasing default is false (true in Safari)
         *   premultipliedAlpha - indicates that the page
  compositor will assume the drawing buffer contains
  colors with pre-multiplied alpha default is true
         *   preserveDrawingBuffer - if true the buffers will
  not be cleared and and will preserve their values
  until cleared or overwritten by author (note that
  p5 clears automatically on draw loop) default is
  true
         *   perPixelLighting - if true, per-pixel lighting
  will be used in the lighting shader otherwise
  per-vertex lighting is used. default is true.
         *   version - either 1 or 2, to specify which WebGL
  version to ask for. By default, WebGL 2 will be
  requested. If WebGL2 is not available, it will
  fall back to WebGL 1. You can check what version
  is used with by looking at the global webglVersion
  property.
  - **obj**: object with key-value pairs

*Sub-module: p5.RendererGL*

---

### constructor

*   An object that one can draw to and then read as a
  texture. While similar to a p5.Graphics, using a
  p5.Framebuffer as a texture will generally run
  much faster, as it lives within the same WebGL
  context as the canvas it is created on. It only
  works in WebGL mode.
         *   - **target**: A p5 global instance or p5.Graphics
  @param [settings] A settings object

*Sub-module: p5.Framebuffer*

---

### pixelDensity

*   Gets or sets the pixel scaling for high pixel
  density displays. By default, the density will
  match that of the canvas the framebuffer was
  created on, which will match the display density.
  Call this method with no arguments to get the
  current density, or pass in a number to set the
  density.
  @param [density] A scaling factor for the number
  of pixels per side of the framebuffer

*Sub-module: p5.Framebuffer*

---

### autoSized

*   Gets or sets whether or not this framebuffer will
  automatically resize along with the canvas it's
  attached to in order to match its size. Call this
  method with no arguments to see if it is currently
  auto-sized, or pass in a boolean to set this
  property.
  @param [autoSized] Whether or not the framebuffer
  should resize along with the canvas it's attached
  to

*Sub-module: p5.Framebuffer*

---

### createCamera

*   Creates and returns a new p5.FramebufferCamera to
  be used while drawing to this framebuffer. The
  camera will be set as the currently active camera.
  - **Returns**: A new camera

*Sub-module: p5.Framebuffer*

---

### remove

*   Removes the framebuffer and frees its resources.

*Sub-module: p5.Framebuffer*

---

### end

*   Begin drawing to this framebuffer. Subsequent
  drawing functions to the canvas the framebuffer is
  attached to will not be immediately visible, and
  will instead be drawn to the framebuffer's
  texture. Call end() when finished to make draw
  functions go right to the canvas again and to be
  able to read the contents of the framebuffer's
  texture.

*Sub-module: p5.Framebuffer*

---

### begin

*   After having previously called begin(), this
  method stops drawing functions from going to the
  framebuffer's texture, allowing them to go right
  to the canvas again. After this, one can read from
  the framebuffer's texture.

*Sub-module: p5.Framebuffer*

---

### begin

*   Run a function while drawing to the framebuffer
  rather than to its canvas. This is equivalent to
  calling framebuffer.begin(), running the function,
  and then calling framebuffer.end(), but ensures
  that one never accidentally forgets begin or end.
  - **callback**: A function to run that draws to
  the canvas. The function will immediately be run,
  but it will draw to the framebuffer instead of the
  canvas.

*Sub-module: p5.Framebuffer*

---

### imageMode

*   Get a region of pixels from the canvas in the form
  of a p5.Image, or a single pixel as an array of
  numbers. Returns an array of [R,G,B,A] values for
  any pixel or grabs a section of an image. If the
  Framebuffer has been set up to not store alpha
  values, then only [R,G,B] will be returned. If no
  parameters are specified, the entire image is
  returned. Use the x and y parameters to get the
  value of one pixel. Get a section of the display
  window by specifying additional w and h
  parameters. When getting an image, the x and y
  parameters define the coordinates for the
  upper-left corner of the image, regardless of the
  current imageMode().
  - **Returns**: the whole p5.Image

*Sub-module: p5.Framebuffer*

---

### imageMode

*   Get a region of pixels from the canvas in the form
  of a p5.Image, or a single pixel as an array of
  numbers. Returns an array of [R,G,B,A] values for
  any pixel or grabs a section of an image. If the
  Framebuffer has been set up to not store alpha
  values, then only [R,G,B] will be returned. If no
  parameters are specified, the entire image is
  returned. Use the x and y parameters to get the
  value of one pixel. Get a section of the display
  window by specifying additional w and h
  parameters. When getting an image, the x and y
  parameters define the coordinates for the
  upper-left corner of the image, regardless of the
  current imageMode().
  - **x**: x-coordinate of the pixel
  - **y**: y-coordinate of the pixel
  - **Returns**: color of pixel at x,y in array format [R,
  G, B, A]

*Sub-module: p5.Framebuffer*

---

### constructor

*   p5 Geometry class
         *   @param [detailX] number of vertices along the
  x-axis.
  @param [detailY] number of vertices along the
  y-axis.
  @param [callback] function to call upon object
  instantiation.

*Sub-module: p5.Geometry*

---

### computeNormals

*   computes smooth normals per vertex as an average
  of each face.
  @chainable

*Sub-module: p5.Geometry*

---

### averageNormals

*   Averages the vertex normals. Used in curved
  surfaces
  @chainable

*Sub-module: p5.Geometry*

---

### averagePoleNormals

*   Averages pole normals. Used in spherical
  primitives
  @chainable

*Sub-module: p5.Geometry*

---

### normalize

*   Modifies all vertices to be centered within the
  range -100 to 100.
  @chainable

*Sub-module: p5.Geometry*

---

### programs

*   Used to set the uniforms of a p5.Shader object.
  Uniforms are used as a way to provide shader
  programs (which run on the GPU) with values from a
  sketch (which runs on the CPU).
  - **uniformName**: the name of the uniform. Must
  correspond to the name used in the vertex and
  fragment shaders
  - **data**: the data to associate with the
  uniform. The type can be a boolean (true/false), a
  number, an array of numbers, or an image
  (p5.Image, p5.Graphics, p5.MediaElement,
  p5.Texture)
  @chainable

*Sub-module: p5.Shader*

---

## Variables

### angle

*   Sets a perspective projection. Accepts the same
  parameters as the global perspective(). More
  information on this function can be found there.

*Sub-module: p5.Camera*

---

### eyeY

*   camera position value on y axis

*Sub-module: p5.Camera*

---

### eyeZ

*   camera position value on z axis

*Sub-module: p5.Camera*

---

### centerX

*   x coordinate representing center of the sketch

*Sub-module: p5.Camera*

---

### centerY

*   y coordinate representing center of the sketch

*Sub-module: p5.Camera*

---

### centerZ

*   z coordinate representing center of the sketch

*Sub-module: p5.Camera*

---

### upX

*   x component of direction 'up' from camera

*Sub-module: p5.Camera*

---

### upY

*   y component of direction 'up' from camera

*Sub-module: p5.Camera*

---

### upZ

*   z component of direction 'up' from camera

*Sub-module: p5.Camera*

---

### target

*   An object that one can draw to and then read as a
  texture. While similar to a p5.Graphics, using a
  p5.Framebuffer as a texture will generally run
  much faster, as it lives within the same WebGL
  context as the canvas it is created on. It only
  works in WebGL mode.
         *   - **target**: A p5 global instance or p5.Graphics
  @param [settings] A settings object

*Sub-module: p5.Framebuffer*

---

### color

*   A texture with the color information of the
  framebuffer. Pass this (or the framebuffer itself)
  to texture() to draw it to the canvas, or pass it
  to a shader with setUniform() to read its data.
  Since Framebuffers are controlled by WebGL, their
  y coordinates are stored flipped compared to
  images and videos. When texturing with a
  framebuffer texture, you may want to flip
  vertically, e.g. with plane(framebuffer.width,
  -framebuffer.height).

*Sub-module: p5.Framebuffer*

---

### depth

*   A texture with the depth information of the
  framebuffer. If the framebuffer was created with {
  depth: false } in its settings, then this property
  will be undefined. Pass this to texture() to draw
  it to the canvas, or pass it to a shader with
  setUniform() to read its data. Since Framebuffers
  are controlled by WebGL, their y coordinates are
  stored flipped compared to images and videos. When
  texturing with a framebuffer texture, you may want
  to flip vertically, e.g. with
  plane(framebuffer.width, -framebuffer.height).

*Sub-module: p5.Framebuffer*

---



==============================================================================
vim:tw=78:ts=8:ft=help:norl:
